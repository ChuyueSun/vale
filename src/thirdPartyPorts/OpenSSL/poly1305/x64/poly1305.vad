///////////////////////////////////////////////////////////////////////////////
//
// Based on poly1305-x86_64.pl from OpenSSL 1.1.1-dev
// See https://github.com/openssl/openssl/blob/master/crypto/poly1305/asm/poly1305-x86_64.pl
// The original file contains the following notices:
//
// # ==================================================================== 
// # Copyright 2016 The OpenSSL Project Authors. All Rights Reserved.
// #
// # Licensed under the OpenSSL license (the "License").  You may not use
// # this file except in compliance with the License.  You can obtain a copy
// # in the file LICENSE in the source distribution or at
// # https://www.openssl.org/source/license.html
// #
// # ====================================================================
// # Written by Andy Polyakov <appro@openssl.org> for the OpenSSL
// # project. The module is, however, dual licensed under OpenSSL and
// # CRYPTOGAMS licenses depending on where you obtain it. For further
// # details see http://www.openssl.org/~appro/cryptogams/.
// # ==================================================================== 
//
///////////////////////////////////////////////////////////////////////////////

include{:verbatim} "../../../../crypto/poly1305/x64/poly1305_math.i.dfy"
include{:verbatim} "../../../../crypto/poly1305/x64/poly1305_util.i.dfy"
include{:verbatim} "../../../../crypto/poly1305/x64/poly1305_bitvectors.i.dfy"
include{:verbatim} "../../../../arch/x64/vale.i.dfy"
include{:verbatim} "../../../../lib/util/operations.i.dfy"
include "../../../../crypto/poly1305/x64/poly1305_decls.i.vad"
include "../../../../arch/x64/decls.vad"

#verbatim
module x64_poly
{
import opened x64_def_s
import opened x64_vale_i
import opened x64_decls_i
import opened x64__Poly1305_math_i
import opened x64__Poly1305_util_i
import opened x64__Poly1305_decls_i
import opened x64__Poly1305_bitvectors_i
import opened operations_i
#endverbatim

procedure{:refined} poly1305_multiply(
    inout operand d1:uint64,
    inout operand d2:uint64,
    inout operand d3:uint64,
          operand r0:uint64,
          operand s1:uint64,
    inout operand h0:uint64,
    inout operand h1:uint64,
    inout operand h2:uint64,
    ghost r1:uint64,
    ghost r:int,
    ghost h:int,
    ghost n:int,
    ghost p:int)
    returns(ghost hh:int)
    modifies
        rax; rdx;
        efl;
    requires{:refined false}
        @d1 == OReg(X86R8);
        @d2 == OReg(X86R9);
        @d3 == OReg(X86R10);
        @r0 == OReg(X86R11);
        @s1 == OReg(X86R13);
        @h0 == OReg(X86R14);
        @h1 == OReg(X86Ebx);
        @h2 == OReg(X86Ebp);
    requires
        n == 0x1_0000_0000_0000_0000;
        p == n * n * 4 - 5;
        r == r1 * n + r0;
        h == h2 * (n * n) + h1 * n + h0;
        r1 % 4 == 0;
        s1 == r1 + r1 / 4;
        h2 * r0 < 7 * (n / 16);
        h0 * r1 < n * (n / 16);
        h1 * r0 < n * (n / 16);
        h2 * s1 < n * (n / 8);
        h0 * r0 < n * (n / 16);
        h1 * s1 < n * (n / 8);
        h2 * s1 < 7 * (5 * n / 64);
        rax == r1;
    ensures
        hh == (n * n) * d3 + n * h1 + h0;
        (h * r) % p == hh % p;
        d3 / 4 * 4 + d3 / 4 < 0x1_0000_0000_0000_0000;
        rax == 0xffff_ffff_ffff_fffc;
{
    lemma_BitwiseAdd64();
    lemma_BitwiseMul64();

    ghost var gd0 := h0 * r0 + h1 * s1;
    ghost var gd1 := h0 * r1 + h1 * r0 + h2 * s1;
    ghost var gd2 := h2 * r0;

    Mul64Wrap(h0);  // h0*r1
    Mov64(d2, rax);
    Mov64(rax, r0);
    Mov64(d3, rdx);
    //assert n * d3 + d2 == old(h0 * r1);

    Mul64Wrap(h0);  // h0*r0
    Mov64(h0, rax); // future h0
    Mov64(rax, r0);
    Mov64(d1, rdx);
    //assert n * d1 + h0 == old(h0 * r0);

    Mul64Wrap(h1);  // h1*r0
    Add64Wrap(d2, rax);
    Mov64(rax, s1);
    Adc64Wrap(d3, rdx);
    //assert n * d3 + d2 == old(h0 * r1 + h1 * r0);

    Mul64Wrap(h1);  // h1*s1
    Mov64(h1, h2);  // borrow h1
    Add64Wrap(h0, rax);
    Adc64Wrap(d1, rdx);
    //assert n * d1 + h0 == old(h0 * r0 + h1 * s1);

    IMul64Wrap(h1, s1); // h2*s1
    Add64Wrap(d2, h1);
    Mov64(h1, d1);
    Adc64Wrap(d3, 0);
    //assert n * d3 + d2 == old(h0 * r1 + h1 * r0 + h2 * s1);

    IMul64Wrap(h2, r0); // h2*r0
    //assert h2 == gd2;
    Add64Wrap(h1, d2);
    Mov64(rax, 0xffff_ffff_ffff_fffc); // mask value
    Adc64Wrap(d3, h2);

    hh := (n * n) * d3 + n * h1 + h0;
    //assert hh == gd2 * (n * n) + gd1 * n + gd0;
    lemma_poly_multiply(n, p, r, h, r0, r1, old(h0), old(h1), old(h2), s1, gd0, gd1, gd2, hh);
}

procedure{:refined} poly1305_reduce(
    inout operand d3:uint64,
    inout operand h0:uint64,
    inout operand h1:uint64,
    inout operand h2:uint64,
    ghost hd:int,
    ghost n:int,
    ghost p:int)
    returns(ghost hh:int)
    modifies
        rax;
        efl;
    requires{:refined false}
        @d3 == OReg(X86R10);
        @h0 == OReg(X86R14);
        @h1 == OReg(X86Ebx);
        @h2 == OReg(X86Ebp);
    requires
        n == 0x1_0000_0000_0000_0000;
        p == n * n * 4 - 5;
        hd == (n * n) * d3 + n * h1 + h0;
        d3 / 4 * 4 + d3 / 4 < 0x1_0000_0000_0000_0000;
        rax == 0xffff_ffff_ffff_fffc;
    ensures
        hh == (n * n) * h2 + n * h1 + h0;
        hd % p == hh % p;
        h2 < 5;
{
    lemma_BitwiseAdd64();
    lemma_poly_bits64();

    And64(rax, d3);
    Mov64(h2, d3);
    Shr64(d3, 2);
    And64(h2, 3);
    Add64Wrap(rax, d3);
    Add64Wrap(h0, rax);
    Adc64Wrap(h1, 0);
    Adc64Wrap(h2, 0);

    ghost var h10 := n * old(h1) + old(h0);
    hh := h10 + rax + (old(d3) % 4) * (n * n);
    lemma_poly_reduce(n, p, hd, old(d3), h10, rax, hh);
}

procedure{:refined}{:bridge} poly1305_iteration(
    inout operand d1:uint64,
    inout operand d2:uint64,
    inout operand d3:uint64,
          operand r0:uint64,
          operand s1:uint64,
    inout operand h0:uint64,
    inout operand h1:uint64,
    inout operand h2:uint64,
    ghost r1:uint64,
    ghost r:int,
    ghost h:int,
    ghost n:int,
    ghost p:int)
    //HACK: returns(ghost hh:int)
    modifies
        rax; rdx;
        efl;
    requires{:refined false}
        @d1 == OReg(X86R8);
        @d2 == OReg(X86R9);
        @d3 == OReg(X86R10);
        @r0 == OReg(X86R11);
        @s1 == OReg(X86R13);
        @h0 == OReg(X86R14);
        @h1 == OReg(X86Ebx);
        @h2 == OReg(X86Ebp);
    requires
        n == 0x1_0000_0000_0000_0000;
        p == n * n * 4 - 5;
        r == r1 * n + r0;
        h == h2 * (n * n) + h1 * n + h0;
        r0 < n / 16;
        r1 < n / 16;
        r1 % 4 == 0;
        s1 == r1 + r1 / 4;
        h2 < 7;
        rax == r1;
    ensures
        // hh == (n * n) * h2 + n * h1 + h0;
        // modp(h * r) == modp(hh);
        // HACK: workaround for lack of {:bridge}/returns:
        exists hh ::
            (   hh == (n * n) * h2 + n * h1 + h0
             && modp(h * r) == modp(hh)
             );
        h2 < 5;
{
    forall x:nat, xb, y:nat, yb :| x < xb && y < yb :: x * y < xb * yb
    {
        lemma_mul_strict_upper_bound(x, xb, y, yb);
    }

    (ghost var hd) := poly1305_multiply(d1, d2, d3, r0, s1, h0, h1, h2, r1, r, h, n, p);
    (ghost var hh) := poly1305_reduce(d3, h0, h1, h2, hd, n, p);
    reveal modp;
    assert hh == (n * n) * h2 + n * h1 + h0 && modp(h * r) == modp(hh);
}

procedure{:timeLimitMultiplier 2} poly1305_blocks(
          operand ctx:uint64,
    inout operand inp:uint64,
    inout operand len:uint64,
          operand padbit:uint64,
    inout operand d1:uint64,
    inout operand d2:uint64,
    inout operand d3:uint64,
    inout operand r0:uint64,
    inout operand r1:uint64,
    inout operand s1:uint64,
    inout operand h0:uint64,
    inout operand h1:uint64,
    inout operand h2:uint64,
    ghost r:int,
    ghost h_in:int,
    ghost n:int,
    ghost p:int,
    ghost ctx_id:heaplet_id,
    ghost inp_id:heaplet_id)
    returns(ghost h:int)
    modifies
        rax; rdx; r15;
        efl;
        mem;
    requires
        @ctx == OReg(X86Edi);
        @inp == OReg(X86Esi);
        @len == OReg(X86Edx);
        @padbit == OReg(X86Ecx);
        @d1 == OReg(X86R8);
        @d2 == OReg(X86R9);
        @d3 == OReg(X86R10);
        @r0 == OReg(X86R11);
        @r1 == OReg(X86R12);
        @s1 == OReg(X86R13);
        @h0 == OReg(X86R14);
        @h1 == OReg(X86Ebx);
        @h2 == OReg(X86Ebp);
        n == 0x1_0000_0000_0000_0000;
        p == n * n * 4 - 5;
        len % 16 == 0; // REVIEW: may be stronger than necessary
        len != 0; //  REVIEW: may be stronger than necessary
        inp + len < 0x1_0000_0000_0000_0000;
        ctx_id != inp_id;
        ValidSrcAddrs(mem, ctx_id, ctx, 64, Public, 24 * 8);
        ValidSrcAddrs(mem, inp_id, inp, 64, Public, len);
        let h0_in := mem[ctx_id].mem64[ctx + 0].v;
        let h1_in := mem[ctx_id].mem64[ctx + 8].v;
        let h2_in := mem[ctx_id].mem64[ctx + 16].v;
        let r0_in := mem[ctx_id].mem64[ctx + 24].v;
        let r1_in := mem[ctx_id].mem64[ctx + 32].v;
        h_in == h2_in * (n * n) + h1_in * n + h0_in;
        r == r1_in * n + r0_in;
        r0_in < n / 16;
        r1_in < n / 16;
        r1_in % 4 == 0;
        h2_in < 5;
        padbit < 2;
    ensures
        h2 < 5;
        ValidSrcAddrs(mem, ctx_id, ctx, 64, Public, 24 * 8);
        ValidSrcAddrs(mem, inp_id, old(inp), 64, Public, old(len));
        h == h2 * (0x1_0000_0000_0000_0000 * 0x1_0000_0000_0000_0000) + h1 * 0x1_0000_0000_0000_0000 + h0;
        modp(h) == poly1305_hash(modp(h_in), padbit * n * n, r, mem[inp_id].mem64, old(inp), old(inp + len));
{
    lemma_BitwiseAdd64();
    lemma_poly_bits64();

    ghost var length := len;

    Shr64(len, 4);
    assert len != 0;
    Mov64(r15, len); // reassign len

    Load64(r0, ctx, 24, Public, ctx_id); // load r
    Load64(s1, ctx, 32, Public, ctx_id);

    Load64(h0, ctx, 0, Public, ctx_id); // load hash value
    Load64(h1, ctx, 8, Public, ctx_id);
    Load64(h2, ctx, 16, Public, ctx_id);

    Mov64(r1, s1);
    Shr64(s1, 2);
    Mov64(rax, r1);
    Add64(s1, r1); // s1 = r1 + (r1 >> 2)

    h := h_in;
    assert modp(h) == poly1305_hash(modp(h_in), padbit * n * n, r, mem[inp_id].mem64, old(inp), inp) by
    {
        reveal modp;
        reveal poly1305_hash;
    }

    while (r15 != 0)
        invariant
            n == 0x1_0000_0000_0000_0000;
            r == r1 * n + r0;
            h == h2 * (0x1_0000_0000_0000_0000 * 0x1_0000_0000_0000_0000) + h1 * 0x1_0000_0000_0000_0000 + h0;
            r0 < n / 16;
            r1 < n / 16;
            r1 % 4 == 0;
            s1 == r1 + r1 / 4;
            h2 < 5;
            rax == r1;
            inp + 16 * r15 == old(inp) + length;
            length == old(len);
            ValidSrcAddrs(mem, ctx_id, ctx, 64, Public, 24 * 8);
            ValidSrcAddrs(mem, inp_id, old(inp), 64, Public, length);
            modp(h) == poly1305_hash(modp(h_in), padbit * n * n, r, mem[inp_id].mem64, old(inp), inp);
        decreases
            r15;
    {
        ghost var hp := h;
        h := h + n * n * padbit + n * mem[inp_id].mem64[inp + 8].v + mem[inp_id].mem64[inp].v;
        ghost var hq := h;

        Add64Wrap(h0, Mem(inp, 0, Public, inp_id)); // accumulate input
        Adc64Wrap(h1, Mem(inp, 8, Public, inp_id));
        AddLea64(inp, inp, 16);
        Adc64Wrap(h2, padbit);

        poly1305_iteration(d1, d2, d3, r0, s1, h0, h1, h2, r1, r, h, n, p);

        Mov64(rax, r1);
        Sub64(r15, 1); // len-=16

        exists hh :: hh == (n * n) * h2 + n * h1 + h0 && modp(h * r) == modp(hh);
        h := hh;

        assert modp(h) == poly1305_hash(modp(h_in), padbit * n * n, r, mem[inp_id].mem64, old(inp), inp) by
        {
            reveal poly1305_hash;
            reveal modp;
            lemma_poly_demod(p, hp, hq - hp, r);
        }
    }

    Store64(ctx, h0, 0, Public, ctx_id);
    Store64(ctx, h1, 8, Public, ctx_id);
    Store64(ctx, h2, 16, Public, ctx_id);
}

#verbatim
} // end module
#endverbatim
