include "../../../arch/x64/X64.Vale.Decls.vaf"

#verbatim interface implementation

module X64.AES

open Types_s
open FStar.Seq
open AES_s
open X64.Machine_s
open X64.Vale.State_i
open X64.Vale.Decls
open AES_helpers_i
open Opaque_i

#endverbatims

#verbatim interface

#reset-options "--max_fuel 5 --initial_fuel 5"
let quad32_to_seq (q:quad32) : Tot (s:seq nat32 { length s == 4 }) =
  let l = [q.lo; q.mid_lo; q.mid_hi; q.hi] in
  let s = of_list l in
  lemma_of_list_length s l; 
  of_list l

#endverbatim

#verbatim
#reset-options "--z3rlimit 100" 
#endverbatim

///////////////////////////
// KEY EXPANSION
///////////////////////////

procedure KeyExpansionRound(
    inline round:nat64,
    inline rcon:imm8,
//    inline taint:taint,
    ghost dst:buffer128,
    ghost key:seq(nat32),
    ghost w_in:seq(nat32)
    ) returns (
    ghost w_out:seq(nat32)
    )
    requires/ensures
        validDstAddrs128(mem, rdx, dst, 11);
    requires
        0 <= round < 10;
        rcon == aes_rcon(round);
        length(key) == 4;
        //length(w_in) == 44;
        length(w_in) == 4 + round*4;
        key_expansion_partial(AES_128, key, w_in, 4+round*4);
        rdx % 16 == 0;
        //validSrcAddrs128(mem, rdx, dst, (round+1));
//        forall j :: 0 <= j <= 10 ==> mem[dst_id].quads[rdx + 16*j].v == Quadword(w_in[4*j], w_in[4*j+1], w_in[4*j+2], w_in[4*j+3]);
        xmm1 == buffer128_read(dst, round, mem);
    reads
        rdx;
    modifies
        mem; xmm1; xmm2; xmm3; efl;
    ensures
//        //validSrcAddrs128(mem, rdx, dst, round+2);
        //modifies_buffer(dst, old(mem), mem);
        modifies_buffer_specific128(dst, old(mem), mem, round+1, round+1);
        xmm1 == buffer128_read(dst, round + 1, mem);
//        forall a :: (a < rdx || a >= rdx + 176) && old(mem)[dst_id].quads?[a] ==> mem[dst_id].quads?[a] && mem[dst_id].quads[a] == old(mem)[dst_id].quads[a];
//        SeqLength(w_out) == 44;
//        mem[dst_id].quads[rdx + 16*0].v == Quadword(w_out[4*0], w_out[4*0+1], w_out[4*0+2], w_out[4*0+3]);
//        forall j :: 0 <= j <= 10 ==> mem[dst_id].quads[rdx + 16*j].v == Quadword(w_out[4*j], w_out[4*j+1], w_out[4*j+2], w_out[4*j+3]);
//        key_expansion_partial(AES_128, key, w_out, 4+(round+1)*4);
{
//    ghost var xmm1_v0 := xmm1;

    AESNI_keygen_assist(xmm2, xmm1, rcon);
//    ghost var xmm2_v1 := xmm2;

    Pshufd(xmm2, xmm2, 255);
//    ghost var xmm2_v2 := xmm2;

    VPSLLDQ4(xmm3, xmm1);
//    ghost var xmm3_v3 := xmm3;

    Pxor(xmm1,xmm3);
//    ghost var xmm1_v4 := xmm1;

    VPSLLDQ4(xmm3, xmm1);
//    ghost var xmm3_v5 := xmm3;

    Pxor(xmm1,xmm3);
//    ghost var xmm1_v6 := xmm1;

    VPSLLDQ4(xmm3, xmm1);
//    ghost var xmm3_v7 := xmm3;

    Pxor(xmm1,xmm3);
//    ghost var xmm1_v8 := xmm1;

    Pxor(xmm1,xmm2);
//    ghost var xmm1_v9 := xmm1;

    Store128_buffer(rdx, xmm1, 16*(round+1), dst, round+1);

    ghost var new_round := round + 1;
    w_out := append(w_in, quad32_to_seq(xmm1));

//    w_out := w_in[new_round*4     := xmm1.lo]
//                 [new_round*4 + 1 := xmm1.mid_lo]
//                 [new_round*4 + 2 := xmm1.mid_hi]
//                 [new_round*4 + 3 := xmm1.hi];
//
//    forall j :| 0 <= j <= 10 :: mem[dst_id].quads[rdx + 16*j].v == Quadword(w_out[4*j], w_out[4*j+1], w_out[4*j+2], w_out[4*j+3])
//    {
//        assert j == new_round ==> mem[dst_id].quads[rdx + 16*j].v == Quadword(w_out[4*j], w_out[4*j+1], w_out[4*j+2], w_out[4*j+3]);
//        assert j != new_round ==> mem[dst_id].quads[rdx + 16*j].v == Quadword(w_out[4*j], w_out[4*j+1], w_out[4*j+2], w_out[4*j+3]);
//    }
//
//    ghost var alg := AES_128();
//    lemma_AES128Size(alg);
//    lemma_KeyExpansionRoundHelper(key, alg, w_in, 4+round*4, xmm1_v0, xmm2_v1, xmm2_v2, xmm3_v3, xmm1_v4, xmm3_v5, xmm1_v6, xmm3_v7, xmm1_v8, xmm1_v9, w_out);
}

/*

#verbatim
let aes_rcon_case (i:int) =
    //ensures  AES_Rcon_Case(i) == AES_Rcon()[i];
    if i = 0 then 0x01 else if i = 1 then 0x02 else if i = 2 then 0x04 else if i = 3 then 0x08 else if i = 4 then 0x10 else if i = 5 then 0x20 else if i = 6 then 0x40 else if i = 7 then 0x80 else if i = 8 then 0x1b else 0x36
#endverbatim

procedure {:recursive} KeyExpansionRoundUnrolledRecursive(
    ghost key:seq(nat32), 
//    ghost w_in:seq(nat32),
//    inline taint:taint,
    ghost dst:buffer128,
    inline n:int)
//    ) returns (
//    ghost w_out:seq(nat32)
//    )
    reads
        rdx;
    modifies
        mem; xmm1; xmm2; xmm3; efl;
    requires/ensures
        validDstAddrs128(mem, rdx, dst, 11);
        rdx % 16 == 0;
    requires
        0 <= n <= 10;
        length(key) == 4;
        quad32_to_seq(xmm1) == key;
//        SeqLength(w_in) == 44;
//        key_expansion_partial(key, AES_128, w_in, 4);
//        ValidSrcAddrs(mem, dst_id, rdx, 128, taint, 16);
        validSrcAddrs128(mem, rdx, dst, 11);
//        forall j :: 0 <= j <= 10 ==> mem[dst_id].quads[rdx + 16*j].v == Quadword(w_in[4*j], w_in[4*j+1], w_in[4*j+2], w_in[4*j+3]);
    ensures
//        ValidSrcAddrs(mem, dst_id, rdx, 128, taint, 16*(n+1));
        modifies_buffer128(dst, old(mem), mem);
        validSrcAddrs128(mem, rdx, dst, 11);
        //forall a :: (a < rdx || a >= rdx + 176) && old(mem)[dst_id].quads?[a] ==> mem[dst_id].quads?[a] && mem[dst_id].quads[a] == old(mem)[dst_id].quads[a];
//        SeqLength(w_out) == 44;
//        xmm1 == Quadword(w_out[4*n], w_out[4*n + 1], w_out[4*n + 2], w_out[4*n + 3]);
//        forall j :: 0 <= j <= 10 ==> mem[dst_id].quads[rdx + 16*j].v == Quadword(w_out[4*j], w_out[4*j+1], w_out[4*j+2], w_out[4*j+3]);
//        key_expansion_partial(key, AES_128, w_out, 4 + 4*n);
{
}
//{
//    inline if (0 < n <= 10) {
//        //ghost var w_mid:seq(nat32);
//        //w_mid := KeyExpansionRoundUnrolledRecursive(key, w_in, taint, dst_id, n-1);
//        KeyExpansionRoundUnrolledRecursive(dst, n-1);
//        //w_out := KeyExpansionRound(n-1, AES_Rcon_Case(n-1), taint, dst_id, key, w_mid);
//        KeyExpansionRound(n-1, aes_rcon_case(n-1), dst);
//    }
//    else {
////        assert KeyExpansionPredicateSpecific(key, AES_128, w_in, 0);
////        assert KeyExpansionPredicateSpecific(key, AES_128, w_in, 1);
////        assert KeyExpansionPredicateSpecific(key, AES_128, w_in, 2);
////        assert KeyExpansionPredicateSpecific(key, AES_128, w_in, 3);
////        w_out := w_in;
//    }
//}

procedure KeyExpansionRoundUnrolled(
    ghost key:seq(nat32), 
//    ghost w_in:seq(nat32),
//    inline taint:taint,
    ghost dst:buffer128)
//    ) returns (
//    ghost w_out:seq(nat32)
//    )
    reads
        rdx;
    modifies
        mem; xmm1; xmm2; xmm3; efl;
    requires/ensures
        validDstAddrs128(mem, rdx, dst, 11);
        rdx % 16 == 0;
    requires
        length(key) == 4;
        key == quad32_to_seq(xmm1);
//        SeqLength(w_in) == 44;
//        key_expansion_partial(key, AES_128, w_in, 4);
//        ValidSrcAddrs(mem, dst_id, rdx, 128, taint, 16);
//        forall j :: 0 <= j <= 10 ==> mem[dst_id].quads[rdx + 16*j].v == Quadword(w_in[4*j], w_in[4*j+1], w_in[4*j+2], w_in[4*j+3]);
    ensures
        modifies_buffer128(dst, old(mem), mem);
        validSrcAddrs128(mem, rdx, dst, 11);
//        forall a :: (a < rdx || a >= rdx + 176) && old(mem)[dst_id].quads?[a] ==> mem[dst_id].quads?[a] && mem[dst_id].quads[a] == old(mem)[dst_id].quads[a];
//        SeqLength(w_out) == 44;
//        forall j :: 0 <= j <= 10 ==> mem[dst_id].quads[rdx + 16*j].v == Quadword(w_out[4*j], w_out[4*j+1], w_out[4*j+2], w_out[4*j+3]);
//        KeyExpansionPredicate(key, AES_128, w_out);
{
    //w_out := KeyExpansionRoundUnrolledRecursive(key, w_in, taint, dst_id, 10);
    KeyExpansionRoundUnrolledRecursive(dst, 10);
}

procedure KeyExpansionImpl(
    ghost key:seq(nat32),
//    inline taint:taint,
    ghost dst:buffer128)
//    ) returns (
//    ghost w:seq(nat32)
//    )
    reads
        rdx;
    modifies
        mem; xmm1; xmm2; xmm3; efl;
    requires
        length(key) == 4;
        key == quad32_to_seq(xmm1);
        validDstAddrs128(mem, rdx, dst, 11);
        rdx % 16 == 0;
    ensures
//        ValidSrcAddrs(mem, dst_id, rdx, 128, taint, 16*11);
        modifies_buffer128(dst, old(mem), mem);
        validSrcAddrs128(mem, rdx, dst, 11);
//        forall a :: (a < rdx || a >= rdx + 176) && old(mem)[dst_id].quads?[a] ==> mem[dst_id].quads?[a] && mem[dst_id].quads[a] == old(mem)[dst_id].quads[a];
//        SeqLength(w) == 44;
//        mem[dst_id].quads[rdx + 16*0].v == Quadword(w[4*0], w[4*0+1], w[4*0+2], w[4*0+3]);
//        forall j :: 0 <= j <= 10 ==> mem[dst_id].quads[rdx + 16*j].v == Quadword(w[4*j], w[4*j+1], w[4*j+2], w[4*j+3]);
//        KeyExpansionPredicate(key, AES_128, w);
{
    Store128_buffer(rdx, xmm1, 0, dst, 0);

//    ghost var w_in := Quadword_to_seq(mem[dst_id].quads[rdx + 16* 0].v) 
//                    + Quadword_to_seq(mem[dst_id].quads[rdx + 16* 1].v)
//                    + Quadword_to_seq(mem[dst_id].quads[rdx + 16* 2].v)
//                    + Quadword_to_seq(mem[dst_id].quads[rdx + 16* 3].v)
//                    + Quadword_to_seq(mem[dst_id].quads[rdx + 16* 4].v)
//                    + Quadword_to_seq(mem[dst_id].quads[rdx + 16* 5].v)
//                    + Quadword_to_seq(mem[dst_id].quads[rdx + 16* 6].v)
//                    + Quadword_to_seq(mem[dst_id].quads[rdx + 16* 7].v)
//                    + Quadword_to_seq(mem[dst_id].quads[rdx + 16* 8].v)
//                    + Quadword_to_seq(mem[dst_id].quads[rdx + 16* 9].v)
//                    + Quadword_to_seq(mem[dst_id].quads[rdx + 16*10].v);
//
//    forall j :| 0 <= j <= 10 :: mem[dst_id].quads[rdx + 16*j].v == Quadword(w_in[4*j], w_in[4*j+1], w_in[4*j+2], w_in[4*j+3])
//    {
//    }

//    w := KeyExpansionRoundUnrolled(key, w_in, taint, dst_id);
    KeyExpansionRoundUnrolled(key, dst);
}

procedure KeyExpansionStdcall(
//    inline taint:taint,
    inline win:bool,
    ghost input_key_b:buffer128,
    ghost output_key_expansion_b:buffer128)
//    ) returns (
//    ghost w:seq(nat32)
//    )
    reads
        rcx; rsi; rdi;
    modifies
        rdx;
        mem; xmm1; xmm2; xmm3; efl;
    requires
        let key_ptr := if win then rcx else rdi;
        let key_expansion_ptr := if win then rdx else rsi;
        key_ptr % 16 == 0;
        key_expansion_ptr % 16 == 0;
        validSrcAddrs128(mem, key_ptr, input_key_b, 1);
        validDstAddrs128(mem, key_expansion_ptr, output_key_expansion_b, 11);
    ensures
        let key_ptr := if win then rcx else rdi;
        let key_expansion_ptr := if win then rdx else rsi;
//        let key := Quadword_to_seq(old(mem)[input_key_id].quads[key_ptr].v);
//        SeqLength(w) == 44;
        validSrcAddrs128(mem, key_expansion_ptr, output_key_expansion_b, 11);
        modifies_buffer128(output_key_expansion_b, old(mem), mem);

//        (forall j :: 0 <= j <= 10 ==> mem[output_key_expansion_id].quads[key_expansion_ptr + 16*j].v == Quadword(w[4*j], w[4*j+1], w[4*j+2], w[4*j+3]));
//        KeyExpansionPredicate(key, AES_128, w);
{
    ghost var key_ptr := if win then rcx else rdi;
    ghost var key_expansion_ptr := if win then rdx else rsi;
//    ghost var key := quadword_to_seq(buffer128_read(input_key_b, 0, 
//            mem[input_key_id].quads[key_ptr].v);

    inline if (win)
    {
        Load128_buffer(xmm1, rcx, 0, input_key_b, 0);
    }
    else
    {
        Load128_buffer(xmm1, rdi, 0, input_key_b, 0);
        Mov64(rdx, rsi);
    }

    ghost var key := quad32_to_seq(xmm1);
    //w := KeyExpansionImpl(key, taint, output_key_expansion_id); // expand key from xmm1 to region pointed to by rdx
    KeyExpansionImpl(key, output_key_expansion_b); // expand key from xmm1 to region pointed to by rdx

//    assert SeqLength(w) == 44;
//    assert forall j :: 0 <= j <= 10 ==> mem[output_key_expansion_id].quads[rdx + 16*j].v == Quadword(w[4*j], w[4*j+1], w[4*j+2], w[4*j+3]);
//    assert KeyExpansionPredicate(key, AES_128, w);
//
//    forall j :| 0 <= j <= 10 :: mem[output_key_expansion_id].quads[key_expansion_ptr + 16*j].v == Quadword(w[4*j], w[4*j+1], w[4*j+2], w[4*j+3])
//    {
//        assert mem[output_key_expansion_id].quads[rdx + 16*j].v == Quadword(w[4*j], w[4*j+1], w[4*j+2], w[4*j+3]);
//        assert rdx == key_expansion_ptr;
//    }

    // Clear secrets out of registers
    Pxor(xmm1, xmm1);
    Pxor(xmm2, xmm2);
    Pxor(xmm3, xmm3);
}
*/

/*

///////////////////////////
// ENCRYPTION
///////////////////////////

procedure AES128EncryptFirstStep(
//    ghost key:seq(nat32),
//    ghost w:seq(nat32),
//    inline taint:taint,
    ghost k_b:buffer128)
//    ) returns (
//    ghost xmm0_trace_out:QuadwordSeq
//    )
    reads
        r8; mem; 
    modifies
        xmm0; xmm2; efl;
    requires/ensures
//      SeqLength(key) == 4;
//      SeqLength(w) == 44;
//      KeyExpansionPredicate(key, AES_128, w);
      validSrcAddrs128(mem, r8, k_b, 1);
//      mem[k_b].quads[r8].v == Quadword(w[0], w[1], w[2], w[3]);
    ensures
//      SeqLength(xmm0_trace_out) == 1;
//      xmm0_trace_out[0] == xmm0;
//      IsValidAES128EncryptionTracePrefix(key, w, old(xmm0), xmm0_trace_out);
{
    // ROUND 0 - XOR

    Load128_buffer(xmm2, r8, 0, k_b, 0);
//    assert xmm2 == Quadword(w[0], w[1], w[2], w[3]);

    Pxor(xmm0, xmm2);

//    xmm0_trace_out := seq(xmm0);
//    assert IsValidAES128EncryptionTracePrefix(key, w, old(xmm0), xmm0_trace_out);
}

procedure AES128EncryptMiddleStep(
    inline round:int,
//    ghost key:seq(nat32),
//    ghost w:seq(nat32),
//    ghost input:Quadword,
//    ghost xmm0_trace_in:QuadwordSeq,
//    inline taint:taint,
    ghost k_b:buffer128)
//    ) returns (
//    ghost xmm0_trace_out:QuadwordSeq
//    )
    reads
        r8; mem;
    modifies
        xmm0; xmm2; efl;
    requires
//        SeqLength(xmm0_trace_in) == round;
        1 <= round <= 9;
//        xmm0_trace_in[round-1] == xmm0;
//        IsValidAES128EncryptionTracePrefix(key, w, input, xmm0_trace_in);
//        SeqLength(key) == 4;
//        SeqLength(w) == 44;
        validSrcAddrs128(mem, r8, k_b, 11);
//        mem[k_b].quads[r8+16*round].v == Quadword(w[4*round], w[4*round+1], w[4*round+2], w[4*round+3]);
//        KeyExpansionPredicate(key, AES_128, w);
    ensures
//        SeqLength(xmm0_trace_out) == round + 1;
//        xmm0_trace_out[round] == xmm0;
//        IsValidAES128EncryptionTracePrefix(key, w, input, xmm0_trace_out);
{
//    ghost var old_xmm0 := xmm0;

    Load128_buffer(xmm2, r8, 16*round, k_b, round);
//    assert xmm2 == seq_to_Quadword(SeqRange(w, 4*round, 4*round+4));
    AESNI_enc(xmm0, xmm2);

//    ghost var new_xmm0 := xmm0;
//    xmm0_trace_out := SeqAppendElt(xmm0_trace_in, new_xmm0);
//
//    lemma_ExtendingAES128EncryptionTracePrefix(key, w, input, round, old_xmm0, new_xmm0, xmm0_trace_in, xmm0_trace_out);
}

procedure AES128EncryptLastStep(
//    ghost key:seq(nat32),
//    ghost w:seq(nat32),
//    ghost input:Quadword,
//    ghost xmm0_trace_in:QuadwordSeq,
//    inline taint:taint,
    ghost k_b:buffer128)
//    ) returns (
//    ghost xmm0_trace_out:QuadwordSeq
//    )
    reads
        r8; mem;
    modifies
        xmm0; xmm2; efl;
    requires
//        SeqLength(key) == 4;
//        SeqLength(w) == 44;
        validSrcAddrs128(mem, r8, k_b, 11);
//        mem[k_b].quads[r8+16*10].v == Quadword(w[40], w[41], w[42], w[43]);
//        KeyExpansionPredicate(key, AES_128, w);
//        SeqLength(xmm0_trace_in) == 10;
//        xmm0_trace_in[9] == xmm0;
//        IsValidAES128EncryptionTracePrefix(key, w, input, xmm0_trace_in);
    ensures
//        SeqLength(xmm0_trace_out) == 11;
//        xmm0_trace_out[10] == xmm0;
//        IsValidAES128EncryptionTracePrefix(key, w, input, xmm0_trace_out);
{
//    ghost var old_xmm0 := xmm0;
//
    Load128_buffer(xmm2, r8, 160, k_b, 10);
//    assert xmm2 == seq_to_Quadword(SeqRange(w, 4*10, 4*10+4));
    AESNI_enc_last(xmm0, xmm2);

//    ghost var new_xmm0 := xmm0;
//    xmm0_trace_out := SeqAppendElt(xmm0_trace_in, new_xmm0);
//
//    lemma_ExtendingAES128EncryptionTracePrefix(key, w, input, 10, old_xmm0, new_xmm0, xmm0_trace_in, xmm0_trace_out);
}

procedure AES128EncryptOneBlock(
//    ghost key:seq(nat32),
//    ghost input:Quadword,
//    ghost w:seq(nat32),
//    inline taint:taint,
    ghost k_b:buffer128)
    reads
        mem; r8; 
    modifies
        xmm0; xmm2; efl;
    requires
        r8 % 16 == 0;
//        SeqLength(key) == 4;
//        xmm0 == input;
//        SeqLength(w) == 44;
        validSrcAddrs128(mem, r8, k_b, 11);
//        forall j :: 0 <= j <= 10 ==> mem[k_b].quads[r8 + 16*j].v == Quadword(w[4*j], w[4*j+1], w[4*j+2], w[4*j+3]);
//        KeyExpansionPredicate(key, AES_128, w);
    ensures
//        (Nb() * (Nr(AES_128) + 1)) / 4 == Nr(AES_128) + 1;
//        (Nb() * (Nr(AES_128) + 1)) % 4 == 0;
//        xmm0 == AES_Encrypt(key, input, AES_128);
{
//    assert mem[k_b].quads[r8 + 16* 0].v == Quadword(w[4* 0], w[4* 0+1], w[4* 0+2], w[4* 0+3]);
//    ghost var xmm0_trace_step0:QuadwordSeq;
//    xmm0_trace_step0 := AES128EncryptFirstStep(key, w, taint, k_b);
    AES128EncryptFirstStep(k_b);

//    assert mem[k_b].quads[r8 + 16* 1].v == Quadword(w[4* 1], w[4* 1+1], w[4* 1+2], w[4* 1+3]);
//    ghost var xmm0_trace_step1:QuadwordSeq;
//    xmm0_trace_step1 := AES128EncryptMiddleStep(1, key, w, input, xmm0_trace_step0, taint, k_b);
    AES128EncryptMiddleStep(1, k_b);

//    assert mem[k_b].quads[r8 + 16* 2].v == Quadword(w[4* 2], w[4* 2+1], w[4* 2+2], w[4* 2+3]);
//    ghost var xmm0_trace_step2:QuadwordSeq;
//    xmm0_trace_step2 := AES128EncryptMiddleStep(2, key, w, input, xmm0_trace_step1, taint, k_b);
    AES128EncryptMiddleStep(2, k_b);
//
//    assert mem[k_b].quads[r8 + 16* 3].v == Quadword(w[4* 3], w[4* 3+1], w[4* 3+2], w[4* 3+3]);
//    ghost var xmm0_trace_step3:QuadwordSeq;
//    xmm0_trace_step3 := AES128EncryptMiddleStep(3, key, w, input, xmm0_trace_step2, taint, k_b);
    AES128EncryptMiddleStep(3, k_b);
//
//    assert mem[k_b].quads[r8 + 16* 4].v == Quadword(w[4* 4], w[4* 4+1], w[4* 4+2], w[4* 4+3]);
//    ghost var xmm0_trace_step4:QuadwordSeq;
//    xmm0_trace_step4 := AES128EncryptMiddleStep(4, key, w, input, xmm0_trace_step3, taint, k_b);
    AES128EncryptMiddleStep(4, k_b);
//
//    assert mem[k_b].quads[r8 + 16* 5].v == Quadword(w[4* 5], w[4* 5+1], w[4* 5+2], w[4* 5+3]);
//    ghost var xmm0_trace_step5:QuadwordSeq;
//    xmm0_trace_step5 := AES128EncryptMiddleStep(5, key, w, input, xmm0_trace_step4, taint, k_b);
    AES128EncryptMiddleStep(5, k_b);
//
//    assert mem[k_b].quads[r8 + 16* 6].v == Quadword(w[4* 6], w[4* 6+1], w[4* 6+2], w[4* 6+3]);
//    ghost var xmm0_trace_step6:QuadwordSeq;
//    xmm0_trace_step6 := AES128EncryptMiddleStep(6, key, w, input, xmm0_trace_step5, taint, k_b);
    AES128EncryptMiddleStep(6, k_b);
//
//    assert mem[k_b].quads[r8 + 16* 7].v == Quadword(w[4* 7], w[4* 7+1], w[4* 7+2], w[4* 7+3]);
//    ghost var xmm0_trace_step7:QuadwordSeq;
//    xmm0_trace_step7 := AES128EncryptMiddleStep(7, key, w, input, xmm0_trace_step6, taint, k_b);
    AES128EncryptMiddleStep(7, k_b);
//
//    assert mem[k_b].quads[r8 + 16* 8].v == Quadword(w[4* 8], w[4* 8+1], w[4* 8+2], w[4* 8+3]);
//    ghost var xmm0_trace_step8:QuadwordSeq;
//    xmm0_trace_step8 := AES128EncryptMiddleStep(8, key, w, input, xmm0_trace_step7, taint, k_b);
    AES128EncryptMiddleStep(8, k_b);
//
//    assert mem[k_b].quads[r8 + 16* 9].v == Quadword(w[4* 9], w[4* 9+1], w[4* 9+2], w[4* 9+3]);
//    ghost var xmm0_trace_step9:QuadwordSeq;
//    xmm0_trace_step9 := AES128EncryptMiddleStep(9, key, w, input, xmm0_trace_step8, taint, k_b);
    AES128EncryptMiddleStep(9, k_b);
//
//    assert mem[k_b].quads[r8 + 16*10].v == Quadword(w[4*10], w[4*10+1], w[4*10+2], w[4*10+3]);
//    ghost var xmm0_trace_step10:QuadwordSeq;
//    xmm0_trace_step10 := AES128EncryptLastStep(key, w, input, xmm0_trace_step9, taint, k_b);
    AES128EncryptLastStep(k_b);

//    lemma_AES128Encrypt(key, input, w, xmm0, xmm0_trace_step10);
//    assert (Nb() * (Nr(AES_128) + 1)) / 4 == Nr(AES_128) + 1;
//    assert (Nb() * (Nr(AES_128) + 1)) % 4 == 0;
//    assert xmm0 == AES_Encrypt(key, input, AES_128);

    // Clear secrets out of registers
    Pxor(xmm2, xmm2);
}

procedure AES128EncryptOneBlockStdcall(
    inline win:bool,
//    ghost key:seq(nat32),
//    ghost input:Quadword,
//    ghost w:seq(nat32),
    ghost input_b:buffer128,
    ghost output_b:buffer128,
    ghost k_b:buffer128)
    reads
        rcx; rdx; rsi; rdi;
    modifies
        r8;
        mem; xmm0; xmm2; efl;
    requires
        // Calling convention
        let output_ptr       := if win then rcx else rdi;
        let input_ptr        := if win then rdx else rsi;
        let expanded_key_ptr := if win then r8 else rdx;

        // Expanded key is readable
        validSrcAddrs128(mem, expanded_key_ptr, k_b, 11);
        expanded_key_ptr % 16 == 0;
//        SeqLength(key) == 4;
//        SeqLength(w) == 44;
//        // And the expanded key in memory matches the abstract version
//        (forall j :: 0 <= j <= 10 ==>
//            mem[k_b].quads[expanded_key_ptr + 16*j].v == Quadword(w[4*j], w[4*j+1], w[4*j+2], w[4*j+3]));
//        KeyExpansionPredicate(key, AES_128, w);

        // One block of input is readable
        validSrcAddrs128(mem, input_ptr, input_b, 1);
        // And it matches the ghost input
//        mem[input_id].quads[input_ptr].v == input;

        // One block of output is writeable
        validSrcAddrs128(mem, output_ptr, output_b, 1);

    ensures
//        (Nb() * (Nr(AES_128) + 1)) / 4 == Nr(AES_128) + 1;
//        (Nb() * (Nr(AES_128) + 1)) % 4 == 0;

        // Calling convention
        let output_ptr       := if win then rcx else rdi;

        // Output is now readable
        validSrcAddrs128(mem, output_ptr, output_b, 1);

        // Framing: Only the output was changed
        modifies_buffer_specific128(output_b, old(mem), mem, 0, 0);

        // Memory contains the proper output value
//        mem[output_id].quads[output_ptr].v == AES_Encrypt(key, input, AES_128);

{
    // Load the input
    inline if (win)
    {
        Load128_buffer(xmm0, rdx, 0, input_b, 0);
    }
    else
    {
        Load128_buffer(xmm0, rsi, 0, input_b, 0);
        Mov64(r8, rdx);
    }

    // Do the work
    AES128EncryptOneBlock(k_b);

    // Store the result in the buffer pointed at by the output_ptr 
    inline if (win)
    {
        Store128_buffer(rcx, xmm0, 0, output_b, 0);
    }
    else
    {
        Store128_buffer(rdi, xmm0, 0, output_b, 0);
    }
}

///////////////////////////
// KEY INVERSION
///////////////////////////

procedure KeyInversionRound(
    inline round:int,
//    inline taint:taint,
    ghost k_b:buffer128)
//    ghost key:seq(nat32),
//    ghost w:seq(nat32),
//    ghost dw_in:seq(nat32)
//    ) returns (
//    ghost dw_out:seq(nat32)
//    )
    requires/ensures
        validSrcAddrs128(mem, rdx, k_b, 11);
    requires
        0 <= round <= 8;
//        SeqLength(key) == 4;
//        SeqLength(w) == 44;
//        SeqLength(dw_in) == 4*(round+1);
//        KeyExpansionPredicate(key, AES_128, w);
//        EqInvkey_expansion_partial(key, AES_128, dw_in, round);
//        forall j :: 0 <= j <= round ==> mem[k_b].quads[rdx + 16*j].v == Quadword(dw_in[4*j], dw_in[4*j+1], dw_in[4*j+2], dw_in[4*j+3]);
//        forall j :: round < j <= 10 ==> mem[k_b].quads[rdx + 16*j].v == Quadword(w[4*j], w[4*j+1], w[4*j+2], w[4*j+3]);
    reads 
        rdx;
    modifies
        mem; xmm1; efl;
    ensures
        modifies_buffer_specific128(k_b, old(mem), mem, round+1, round+1);
//        forall a :: (a < rdx || a >= rdx + 176) && old(mem)[k_b].quads?[a] ==> mem[k_b].quads?[a] && mem[k_b].quads[a] == old(mem)[k_b].quads[a];
//        forall j :: round+1 < j <= 10 ==> mem[k_b].quads[rdx + 16*j].v == Quadword(w[4*j], w[4*j+1], w[4*j+2], w[4*j+3]);
//        SeqLength(dw_out) == 4*(round + 2);
//        forall j :: 0 <= j <= round+1 ==> mem[k_b].quads[rdx + 16*j].v == Quadword(dw_out[4*j], dw_out[4*j+1], dw_out[4*j+2], dw_out[4*j+3]);
//        EqInvkey_expansion_partial(key, AES_128, dw_out, round+1);
{
//    assert mem[k_b].quads[rdx + 16*(round+1)].v == Quadword(w[(round+1)*4], w[(round+1)*4 + 1], w[(round+1)*4 + 2], w[(round+1)*4 + 3]);

    Load128_buffer(xmm1, rdx, 16*(round+1), k_b, round+1);
//    assert xmm1 == Quadword(w[(round+1)*4], w[(round+1)*4 + 1], w[(round+1)*4 + 2], w[(round+1)*4 + 3]);
//    ghost var ws := SeqRange(w, (round+1)*4, (round+1)*4 + 4);
//    assert ws[0] == w[(round+1)*4] && ws[1] == w[(round+1)*4+1] && ws[2] == w[(round+1)*4+2] && ws[3] == w[(round+1)*4+3];
//    assert xmm1 == seq_to_Quadword(ws);
    AESNI_imc(xmm1, xmm1);
    Store128_buffer(rdx, xmm1, 16*(round+1), k_b, round+1);

//    dw_out := dw_in + Quadword_to_seq(xmm1);
//    lemma_KeyInversionRoundHelper(round+1, key, w, dw_in, dw_out);
//
//    forall j :| round+1 < j <= 10 :: mem[k_b].quads[rdx + 16*j].v == Quadword(w[4*j], w[4*j+1], w[4*j+2], w[4*j+3]) {
//    }
//
//    forall j :| 0 <= j <= round + 1 :: mem[k_b].quads[rdx + 16*j].v == Quadword(dw_out[4*j], dw_out[4*j+1], dw_out[4*j+2], dw_out[4*j+3]) {
//    }
}

procedure {:recursive} KeyInversionRoundUnrolledRecursive(
    inline rounds:int,
//    inline taint:taint,
    ghost k_b:buffer128)
//    ghost key:seq(nat32),
//    ghost w:seq(nat32),
//    ghost dw_in:seq(nat32)
//    ) returns (
//    ghost dw_out:seq(nat32)
//    )
    requires/ensures
        validSrcAddrs128(mem, rdx, k_b, 11);
    requires
        0 <= rounds <= 9;
        rdx % 16 == 0;
//        SeqLength(key) == 4;
//        SeqLength(w) == 44;
//        SeqLength(dw_in) == 4;
//        KeyExpansionPredicate(key, AES_128, w);
//        EqInvkey_expansion_partial(key, AES_128, dw_in, 0);
//        mem[k_b].quads[rdx+16*0].v == Quadword(dw_in[4*0], dw_in[4*0+1], dw_in[4*0+2], dw_in[4*0+3]);
//        forall j :: 0 <= j <= 0 ==> mem[k_b].quads[rdx + 16*j].v == Quadword(dw_in[4*j], dw_in[4*j+1], dw_in[4*j+2], dw_in[4*j+3]);
//        forall j :: 0 < j <= 10 ==> mem[k_b].quads[rdx + 16*j].v == Quadword(w[4*j], w[4*j+1], w[4*j+2], w[4*j+3]);
    reads 
        rdx;
    modifies
        mem; xmm1; efl;
    ensures
        modifies_buffer128(k_b, old(mem), mem);
//        forall a :: (a < rdx || a >= rdx + 176) && old(mem)[k_b].quads?[a] ==> mem[k_b].quads?[a] && mem[k_b].quads[a] == old(mem)[k_b].quads[a];
//        SeqLength(dw_out) == 4*(rounds+1);
//        forall j :: 0 <= j <= rounds ==> mem[k_b].quads[rdx + 16*j].v == Quadword(dw_out[4*j], dw_out[4*j+1], dw_out[4*j+2], dw_out[4*j+3]);
//        forall j :: rounds < j <= 10 ==> mem[k_b].quads[rdx + 16*j].v == Quadword(w[4*j], w[4*j+1], w[4*j+2], w[4*j+3]);
//        EqInvkey_expansion_partial(key, AES_128, dw_out, rounds);
{
//    inline if (0 < rounds <= 9) {
//        ghost var dw_mid;
//        dw_mid := KeyInversionRoundUnrolledRecursive(rounds-1, taint, k_b, key, w, dw_in);
//        dw_out := KeyInversionRound(rounds-1, taint, k_b, key, w, dw_mid);
//    }
//    else {
//        dw_out := dw_in;
//    }
}

procedure KeyInversionImpl(
//    ghost key:seq(nat32),
//    ghost w:seq(nat32),
//    inline taint:taint,
    ghost k_b:buffer128)
//    ) returns (
//    ghost dw:seq(nat32)
//    )
    requires/ensures
        validSrcAddrs128(mem, rdx, k_b, 11);
    requires
        rdx % 16 == 0;
//        SeqLength(key) == 4;
//        SeqLength(w) == 44;
//        forall j :: 0 <= j <= 10 ==> mem[k_b].quads[rdx + 16*j].v == Quadword(w[4*j], w[4*j+1], w[4*j+2], w[4*j+3]);
//        KeyExpansionPredicate(key, AES_128, w);
    ensures
        modifies_buffer128(k_b, old(mem), mem);
//        forall a :: (a < rdx || a >= rdx + 176) && old(mem)[k_b].quads?[a] ==> mem[k_b].quads?[a] && mem[k_b].quads[a] == old(mem)[k_b].quads[a];
//        SeqLength(dw) == 44;
//        EqInvKeyExpansionPredicate(key, AES_128, dw);
//        forall j :: 0 <= j <= 10 ==> mem[k_b].quads[rdx + 16*j].v == Quadword(dw[4*j], dw[4*j+1], dw[4*j+2], dw[4*j+3]);
    reads
        rdx;
    modifies
        mem; xmm1; efl;
{
//    lemma_KeyExpansionPredicateImpliesExpandKey(key, AES_128, w);
//    ghost var dw1 := seq(w[0], w[1], w[2], w[3]);
//
//    ghost var dw2;
//    dw2 := KeyInversionRoundUnrolledRecursive(9, taint, k_b, key, w, dw1);
    KeyInversionRoundUnrolledRecursive(9, k_b);
//
//    dw := dw2 + seq(w[40], w[41], w[42], w[43]);
//    assert SeqLength(dw) == 44;
//    forall j :| 0 <= j <= 10 :: mem[k_b].quads[rdx + 16*j].v == Quadword(dw[4*j], dw[4*j+1], dw[4*j+2], dw[4*j+3])
//    {
//    }
//    assert EqInvKeyExpansionPredicate(key, AES_128, dw);
}

procedure KeyExpansionAndInversionStdcall(
//    inline taint:taint,
    inline win:bool,
    ghost input_key_b:buffer128,
    ghost output_key_expansion_b:buffer128)
//    ) returns (
//    ghost dw:seq(nat32)
//    )
    reads
        rcx; rsi; rdi;
    modifies
        rdx;
        mem; xmm1; xmm2; xmm3; efl;
    requires
//        HasStackSlots(stack, 2);
        let key_ptr := if win then rcx else rdi;
        let key_expansion_ptr := if win then rdx else rsi;
        key_ptr % 16 == 0;
        key_expansion_ptr % 16 == 0;
        validSrcAddrs128(mem, key_ptr, input_key_b, 1);
        validDstAddrs128(mem, key_expansion_ptr, output_key_expansion_b, 11);
    ensures
        let key_ptr := if win then rcx else rdi;
        let key_expansion_ptr := if win then rdx else rsi;
//        let key := Quadword_to_seq(old(mem)[input_key_id].quads[key_ptr].v);
//        SeqLength(dw) == 44;
//        ValidSrcAddrs(mem, output_key_expansion_id, key_expansion_ptr, 128, taint, 176);
        validSrcAddrs128(mem, key_expansion_ptr, output_key_expansion_b, 11);
        modifies_buffer128(output_key_expansion_b, old(mem), mem);
//        (forall a :: (a < key_expansion_ptr || a >= key_expansion_ptr + 176) && old(mem)[output_key_expansion_id].quads?[a] ==> mem[output_key_expansion_id].quads?[a] && mem[output_key_expansion_id].quads[a] == old(mem)[output_key_expansion_id].quads[a]);
//        (forall j :: 0 <= j <= 10 ==> mem[output_key_expansion_id].quads[key_expansion_ptr + 16*j].v == Quadword(dw[4*j], dw[4*j+1], dw[4*j+2], dw[4*j+3]));
//        EqInvKeyExpansionPredicate(key, AES_128, dw);
{
    ghost var key_ptr := if win then rcx else rdi;
    ghost var key_expansion_ptr := if win then rdx else rsi;
//    ghost var key := Quadword_to_seq(mem[input_key_id].quads[key_ptr].v);

//    LoadStack(eax, 0);                                     // eax := key_ptr (from stack position 0)
    inline if (win)
    {
        Load128_buffer(xmm1, rcx, 0, input_key_b, 0);
    }
    else
    {
        Load128_buffer(xmm1, rdi, 0, input_key_b, 0);
        Mov64(rdx, rsi);
    }
//    ghost var w;
//    w := KeyExpansionImpl(key, taint, output_key_expansion_id); // expand key from xmm1 to region pointed to by rdx
//    dw := KeyInversionImpl(key, w, taint, output_key_expansion_id);
    ghost var key := quad32_to_seq(xmm1);
    KeyExpansionImpl(key, output_key_expansion_b); // expand key from xmm1 to region pointed to by rdx

//    forall j :| 0 <= j <= 10 :: mem[output_key_expansion_id].quads[key_expansion_ptr + 16*j].v == Quadword(dw[4*j], dw[4*j+1], dw[4*j+2], dw[4*j+3])
//    {
//        assert mem[output_key_expansion_id].quads[rdx + 16*j].v == Quadword(dw[4*j], dw[4*j+1], dw[4*j+2], dw[4*j+3]);
//        assert rdx == key_expansion_ptr;
//    }

    // Clear secrets out of registers
//    Xor32(eax, eax);
    Pxor(xmm1, xmm1);
    Pxor(xmm2, xmm2);
    Pxor(xmm3, xmm3);
}
*/
