include "../../../arch/x64/X64.Vale.InsBasic.vaf"
include "../../../arch/x64/X64.Vale.InsVector.vaf"
include "../../../arch/x64/X64.Vale.InsAes.vaf"

module X64.GF128_Mul

#verbatim{:interface}{:implementation}
open Types_s
open Types_i
open Math.Poly2_s
open Math.Poly2_i
open Math.Poly2.Bits_s
open Math.Poly2.Lemmas_i
open GF128_s
open GF128_i
open X64.Machine_s
open X64.Vale.State_i
open X64.Vale.Decls_i
open X64.Vale.InsBasic
open X64.Vale.InsMem
open X64.Vale.InsVector
open X64.Vale.InsAes
open X64.Vale.QuickCode_i
open X64.Vale.QuickCodes_i
#endverbatim

procedure{:quick} ShiftLeft128_1(ghost a:poly)
    modifies
        efl;
        xmm1; // ...TODO
    requires
        degree(a) <= 127;
        xmm1 == to_quad32(a);
    ensures
        xmm1 == to_quad32(shift(a, 1));
{
    // TODO: Psrll by 1, Psrld by 31, VPSLLDQ4, Pxor
    assume False;
    lemma_shift_left_1(a);
}

procedure{:quick} ClmulRev64(ghost a:poly, ghost b:poly, inline dstHi:bool, inline srcHi:bool)
    modifies
        efl;
        xmm1; xmm2; // ...TODO
    requires
        degree(a) <= 63;
        degree(b) <= 63;
        reverse(a, 63) == of_double32(if dstHi then quad32_double_hi(xmm1) else quad32_double_lo(xmm1));
        reverse(b, 63) == of_double32(if srcHi then quad32_double_hi(xmm2) else quad32_double_lo(xmm2));
    ensures
        xmm1 == to_quad32(reverse(old(mul(a, b)), 127));
{
    // TODO: Pclmullqlqdq, ShiftLeft128_1, lemma_mul_reverse_shift_1, ...
    assume False;
}

procedure{:quick} ClmulRev128(ghost a:poly, ghost b:poly) returns(ghost hi:poly, ghost lo:poly)
    modifies
        efl;
        xmm1; xmm2; // ...TODO
    requires
        degree(a) <= 127;
        degree(b) <= 127;
        xmm1 == to_quad32(reverse(a, 127));
        xmm2 == to_quad32(reverse(b, 127));
    ensures
        degree(lo) <= 127;
        degree(hi) <= 127;
        old(reverse(mul(a, b), 255)) == add(shift(hi, 128), lo);
        xmm1 == to_quad32(lo);
        xmm2 == to_quad32(hi);
{
    // TODO: ClmulRev64, lemma_gf128_mul, ...
    hi := zero;
    lo := zero;
    assume False;
}

procedure{:quick} ReduceMulRev128(ghost a:poly, ghost b:poly)
    modifies
        efl;
        xmm1; xmm2; // ...TODO
    requires
        degree(a) <= 127;
        degree(b) <= 127;
        xmm1 == to_quad32(reverse(a, 127));
        xmm2 == to_quad32(reverse(b, 127));
    ensures
        xmm1 == to_quad32(reverse(gf128_mul(a, b), 127));
{
    // TODO: ClmulRev128, lemma_gf128_reduce, ...
    assume False;
}
