include "../../../arch/x64/X64.Vale.InsBasic.vaf"
include "../../../arch/x64/X64.Vale.InsMem.vaf"
include "../../../arch/x64/X64.Vale.InsVector.vaf"
//include "../../../arch/x64/X64.Vale.InsAes.vaf"
include "X64.AES.vaf"

module X64.GHash

#verbatim{:interface}{:implementation}
open FStar.Seq
open Types_s
open Types_i
open AES_s
open GHash_s
open GF128_s
open X64.AES
open X64.Machine_s
open X64.Vale.State_i
open X64.Vale.Decls_i
open X64.Vale.InsBasic
open X64.Vale.InsMem
open X64.Vale.InsVector
open X64.Vale.InsAes
open X64.Vale.QuickCode_i
open X64.Vale.QuickCodes_i
#endverbatim

#verbatim{:interface}
let cast_seq_to_ghash_plain (s:seq quad32) : ghash_plain =
    if length s > 0 then s
    else (create 1 (Quad32 0 0 0 0))
#endverbatim

#reset-options "--z3rlimit 40"

///////////////////////////
// GHash
///////////////////////////

procedure {:quick} compute_Y0()
    modifies xmm0; efl;
    ensures xmm0 == Quad32(0, 0, 0, 0);
{
    Pxor(xmm0, xmm0);
    lemma_quad32_xor();
}

procedure {:quick} gf128_mul()
    reads xmm2;
    modifies xmm0;
    ensures xmm0 == to_quad32(gf128_mul(of_quad32(old(xmm0)), of_quad32(xmm2)));
{
    assume false;
}

procedure {:quick} ghash_core(
    ghost in_b:buffer128
    )
    lets in_ptr @= rax; len @= rcx; output @= xmm0; h @= xmm2;

    reads
        in_ptr; len; h;
        mem;

    modifies
        rdx; r9; xmm1; //r10; xmm0; xmm2; xmm4; icb; mem; efl;
        output; efl;

    requires
        // GHash reqs
        validSrcAddrs128(mem, in_ptr, in_b, len);
        in_ptr  + 16 * len < nat64_max;
        len > 0;
        buffer_length(in_b) == len;

    ensures
         length(buffer128_as_seq(mem, in_b)) > 0;
         //output == ghash(h, buffer128_as_seq(mem, in_b));
{
    Mov64(rdx, 0);
    Mov64(r9, in_ptr);
    compute_Y0();

    while (rdx != len)
        invariant
            //////////////////// Basic indexing //////////////////////
            0 <= rdx <= len;
            r9 == in_ptr + 16 * rdx;
            
            //////////////////// From requires //////////////////////
            // GHash reqs
            validSrcAddrs128(mem, in_ptr, in_b, len);
            in_ptr  + 16 * len < nat64_max;
            len > 0;
            buffer_length(in_b) == len;

            //////////////////// Postcondition goals //////////////////////
            rdx == 0 ==> output == Quad32(0, 0, 0, 0);
            rdx > 0 ==> output == ghash(h, slice(buffer128_as_seq(mem, in_b), 0, rdx));

        decreases
            len - rdx;
    {
        Load128_buffer(xmm1, r9, 0, in_b, rdx);
        Pxor(output, xmm1);    // Y_i := Y_{i-1} ^ x_i
        // Believes this:
        //assert rdx == 0 ==> output == quad32_xor(Quad32(0, 0, 0, 0), get_last_slice_workaround(buffer128_as_seq(mem, in_b), 0, 1));
        ghost var old_output := output;

        gf128_mul();        // xmm0/output := Y_i * H
        assert rdx == 0 ==> output == to_quad32(gf128_mul(of_quad32(old_output), of_quad32(h)));

        Add64(rdx, 1);
        Add64(r9, 16);
        //assert rdx == 1 ==> output == ghash(h, slice(buffer128_as_seq(mem, in_b), 0, rdx));
        //assert rdx == 1 ==> output == ghash(h, get_last_slice_workaround(buffer128_as_seq(mem, in_b), 0, rdx));
        assume false;
    }
    
    assert length(buffer128_as_seq(mem, in_b)) > 0;
    assert length(buffer128_as_seq(mem, in_b)) == len;
    assert rdx == len;
    //assert eq(buffer128_as_seq(mem, in_b), slice(buffer128_as_seq(mem, in_b), 0, rdx));
    // Call a helpful lemma
}

