include "../../../arch/x64/X64.Vale.InsBasic.vaf"
include "../../../arch/x64/X64.Vale.InsMem.vaf"
include "../../../arch/x64/X64.Vale.InsVector.vaf"
include "X64.AES.vaf"

module X64.GHash

#verbatim{:interface}{:implementation}
open FStar.Seq
open Types_s
open Types_i
open AES_s
open GHash_s
open GHash_i
open GF128_s
open X64.AES
open X64.Machine_s
open X64.Vale.State_i
open X64.Vale.Decls_i
open X64.Vale.InsBasic
open X64.Vale.InsMem
open X64.Vale.InsVector
open X64.Vale.InsAes
open X64.Vale.QuickCode_i
open X64.Vale.QuickCodes_i
#endverbatim

#verbatim{:interface}
let get_last_slice_workaround (s:seq quad32) (start_pos end_pos:int)  =
  if 0 <= start_pos && start_pos < end_pos && end_pos <= length s then
    last (slice s start_pos end_pos)
  else
    Quad32 0 0 0 0 

let slice_workaround (s:seq quad32) (start_pos end_pos:int)  =
  if 0 <= start_pos && start_pos < end_pos && end_pos <= length s then
    slice s start_pos end_pos
  else
    create 1 (Quad32 0 0 0 0)
#endverbatim

#reset-options "--z3rlimit 40"

///////////////////////////
// GHash
///////////////////////////

procedure {:quick} compute_Y0()
    modifies xmm0; efl;
    ensures xmm0 == Quad32(0, 0, 0, 0);
{
    Pxor(xmm0, xmm0);
    lemma_quad32_xor();
}

procedure {:quick} gf128_mul()
    reads xmm2;
    modifies xmm0;
    ensures xmm0 == to_quad32(gf128_mul(of_quad32(old(xmm0)), of_quad32(xmm2)));
{
/////////////////////  TODO  ////////////////////
    assume false;
}

procedure {:quick} compute_ghash_incremental(
    ghost in_b:buffer128
    )
    lets in_ptr @= rax; len @= rcx; output @= xmm0; h @= xmm2;

    reads
        in_ptr; len; h;
        mem;

    modifies
        rdx; r9; xmm1; 
        output; efl;

    requires
        // GHash reqs
        len > 0 ==> validSrcAddrs128(mem, in_ptr, in_b, len);
        len > 0 ==> in_ptr  + 16 * len < nat64_max;
        len > 0 ==> buffer_length(in_b) == len;

    ensures
        len == 0 ==> rdx == old(rdx) /\ r9 == old(r9) /\ xmm1 == old(xmm1) /\ output == old(output);
        len > 0 ==> length(buffer128_as_seq(mem, in_b)) > 0 /\ output == ghash_incremental(h, old(output), buffer128_as_seq(mem, in_b));
{
    if (len != 0) {
        Mov64(rdx, 0);
        Mov64(r9, in_ptr);

        while (rdx != len)
            invariant
                //////////////////// Basic indexing //////////////////////
                0 <= rdx <= len;
                r9 == in_ptr + 16 * rdx;
                
                //////////////////// From requires //////////////////////
                // GHash reqs
                validSrcAddrs128(mem, in_ptr, in_b, len);
                in_ptr  + 16 * len < nat64_max;
                len > 0;
                buffer_length(in_b) == len;

                //////////////////// Postcondition goals //////////////////////
                rdx == 0 ==> output == old(output);
                rdx > 0 ==> output == ghash_incremental(h, old(output), slice_workaround(buffer128_as_seq(mem, in_b), 0, rdx));

            decreases
                len - rdx;
        {
            Load128_buffer(xmm1, r9, 0, in_b, rdx);
            Pxor(output, xmm1);    // Y_i := Y_{i-1} ^ x_i
            gf128_mul();           // xmm0/output := Y_i * H

            Add64(rdx, 1);
            Add64(r9, 16);
        }
    }
}


procedure {:quick} compute_ghash_incremental_register()
    lets input @= xmm1; output @= xmm0; h @= xmm2;
    reads
        input; h;

    modifies
        output; efl;

    requires
    ensures
        output == ghash_incremental(h, old(output), create(1, old(input)));
{
    Pxor(output, input);    // Y_i := Y_{i-1} ^ x_i
    gf128_mul();         // xmm0/output := Y_i * H
}


procedure {:quick}  ghash_core(
    ghost in_b:buffer128
    )
    lets in_ptr @= rax; len @= rcx; output @= xmm0; h @= xmm2;

    reads
        in_ptr; len; h;
        mem;

    modifies
        rdx; r9; xmm1; 
        output; efl;

    requires
        // GHash reqs
        len > 0 ==> validSrcAddrs128(mem, in_ptr, in_b, len);
        len > 0 ==> in_ptr  + 16 * len < nat64_max;
        len > 0 ==> buffer_length(in_b) == len;

    ensures
        len == 0 ==> rdx == old(rdx) /\ r9 == old(r9) /\ xmm1 == old(xmm1) /\ output == old(output);
        len > 0 ==> length(buffer128_as_seq(mem, in_b)) > 0 /\ output == ghash(h, buffer128_as_seq(mem, in_b));
{
    if (len != 0) {
        compute_Y0();
        compute_ghash_incremental(in_b);
        ghash_incremental_to_ghash(old(h), buffer128_as_seq(mem, in_b));
    }
}

