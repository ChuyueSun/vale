include "X64.Vale.InsBasic.vaf"

module X64.Vale.InsVector

#verbatim{:interface}
open Types_s
open X64.Machine_s
open X64.Vale.State_i
open X64.Vale.Decls_i
open X64.Vale.QuickCode_i
#endverbatim

#verbatim
open X64.Machine_s
open X64.Vale
open X64.Vale.State_i
open X64.Vale.StateLemmas_i
open X64.Vale.Decls_i
open FStar.UInt
module S = X64.Semantics_s
module P = X64.Print_s
#reset-options "--initial_fuel 2 --max_fuel 2 --z3rlimit 20"
#endverbatim

var{:state xmm(0)} xmm0:quad32;
var{:state xmm(1)} xmm1:quad32;
var{:state xmm(2)} xmm2:quad32;
var{:state xmm(3)} xmm3:quad32;
var{:state xmm(4)} xmm4:quad32;
var{:state xmm(5)} xmm5:quad32;
var{:state xmm(6)} xmm6:quad32;
var{:state xmm(7)} xmm7:quad32;

procedure{:instruction Ins(S.Pxor(dst, src))}{:quick exportOnly} Pxor(inout dst:xmm, src:xmm)
  modifies efl;
  ensures
    dst == old(quad32_xor(dst, src));
{
}

procedure{:instruction Ins(S.Pshufd(dst, src, permutation))}{:quick exportOnly}
          Pshufd(inout dst:xmm, src:xmm, inline permutation:imm8)
  modifies efl;
  ensures
    dst == old(Quad32(select_word(src, get_lo_bits    (byte_to_twobits(permutation))),
                      select_word(src, get_mid_lo_bits(byte_to_twobits(permutation))),
                      select_word(src, get_mid_hi_bits(byte_to_twobits(permutation))),
                      select_word(src, get_hi_bits    (byte_to_twobits(permutation)))));
{
}

procedure{:instruction Ins(S.VPSLLDQ(dst, src, 4))}{:quick exportOnly} VPSLLDQ4(inout dst:xmm, src:xmm)
  modifies efl;
  ensures
    dst == old(Quad32(0, src.lo, src.mid_lo, src.mid_hi));
{
}

procedure{:instruction Ins(S.MOVDQU(Mov128Xmm(dst),Mov128Xmm(src)))}{:quick exportOnly} Mov128(inout dst:xmm, src:xmm)
    ensures
        dst == old(src);
{
}

procedure{:instruction Ins(S.MOVDQU(Mov128Xmm(dst), Mov128Mem(MReg(get_reg(src), offset))))}{:quick exportOnly} Load128_buffer(
    out dst:xmm,
        src:reg_opr64,
        inline offset:int,
        ghost b:buffer128,
        ghost index:int)
    reads
        mem;
    requires
        valid_src_addr(mem, b, index);
        src + offset == buffer_addr(b) + 16 * index;
    ensures
        dst == buffer128_read(b, index, mem);
{
    lemma_valid_mem128(b, index, mem);
    lemma_load_mem128(b, index, mem);
}

procedure{:instruction Ins(S.MOVDQU(Mov128Mem(MReg(get_reg(dst), offset)), Mov128Xmm(src)))}{:quick exportOnly} Store128_buffer(
        dst:reg_opr64,
        src:xmm,
        inline offset:int,
        ghost b:buffer128,
        ghost index:int)
    modifies
        mem;
    requires
        valid_dst_addr(mem, b, index);
        dst + offset == buffer_addr(b) + 16 * index;
    ensures
        modifies_mem(loc_buffer(b), old(mem), mem);
        mem == old(buffer128_write(b, index, src, mem));
{
    lemma_valid_mem128(b, index, old(mem));
    lemma_store_mem128(b, index, old(src), old(mem));
}

