include "X64.Vale.InsBasic.vaf"
include "X64.Vale.InsVector.vaf"

module X64.Vale.InsAes

#verbatim{:interface}
open Types_s
open AES_s
open X64.Machine_s
open X64.Vale.State_i
open X64.Vale.Decls_i
open X64.Vale.QuickCode_i
#endverbatim

#verbatim
open Types_s
open X64.Machine_s
open X64.Vale
open X64.Vale.State_i
open X64.Vale.StateLemmas_i
open X64.Vale.Decls_i
module S = X64.Semantics_s
module P = X64.Print_s
#reset-options "--initial_fuel 2 --max_fuel 2 --z3rlimit 20"
#endverbatim

procedure{:instruction Ins(S.AESNI_enc(dst, src))}{:quick exportOnly}
          AESNI_enc(inout dst:xmm, src:xmm)
  modifies efl;
  ensures
    dst == old(quad32_xor(mix_columns(sub_bytes(shift_rows(src))), src));
{
}

procedure{:instruction Ins(S.AESNI_enc_last(dst, src))}{:quick exportOnly}
          AESNI_enc_last(inout dst:xmm, src:xmm)
  modifies efl;
  ensures
    dst == old(quad32_xor(sub_bytes(shift_rows(src)), src));
{
}

procedure{:instruction Ins(S.AESNI_dec(dst, src))}{:quick exportOnly}
          AESNI_dec(inout dst:xmm, src:xmm)
  modifies efl;
  ensures
    dst == old(quad32_xor(inv_mix_columns(inv_sub_bytes(inv_shift_rows(src))), src));
{
}

procedure{:instruction Ins(S.AESNI_dec_last(dst, src))}{:quick exportOnly}
          AESNI_dec_last(inout dst:xmm, src:xmm)
  modifies efl;
  ensures
    dst == old(quad32_xor(inv_sub_bytes(inv_shift_rows(src)), src));
{
}

procedure{:instruction Ins(S.AESNI_imc(dst, src))}{:quick exportOnly}
          AESNI_imc(inout dst:xmm, src:xmm)
  modifies efl;
  ensures
    dst == old(inv_mix_columns(src));
{
}

procedure{:instruction Ins(S.AESNI_keygen_assist(dst, src, imm))}{:quick exportOnly}
          AESNI_keygen_assist(inout dst:xmm, src:xmm, inline imm:imm8)
  modifies efl;
  ensures
    dst == old(Quad32(sub_word(src.mid_lo), 
                      logxor(rot_word(sub_word(src.mid_lo)), imm),
                      sub_word(src.hi),
                      logxor(rot_word(sub_word(src.hi)), imm)));
{
}

