#verbatim
module FStar2

open Vale
open Semantics
open FStar.UInt64
#endverbatim

var{:state ok()} ok:bool;
var{:state reg(Rax)} rax:int;
var{:state reg(RbX)} rbx:int;
var{:state flags()} efl:int;
var{:state mem()} mem:int;

procedure{:instruction Ins(Add64(dst,src))} Add64Wrap(inout dst_operand dst:uint64, operand src:uint64)
    modifies
        efl;
    ensures
        dst == old(dst + src) % nat64_max;
        //Cf(efl) == old(dst + src >= 0x1_0000_0000_0000_0000);
{
}


procedure p()
    modifies
        rax; efl;
    requires
        0 <= rax && rax < 10;
    ensures
        rax == old(rax) + 4;
{
    Add64Wrap(rax, 2);
    Add64Wrap(rax, 2);
}


/*
procedure Imm(out register x:int, inline y:int)
    ensures
        x == y;
{
    assume false;
}

procedure Increment(inout register x:int)
    ensures
        x == old(x) + 1;
{
    assume false;
}

procedure Add(inout register x:int, register y:int)
    ensures
        x == old(x + y);
{
    assume false;
}

procedure AddReg(inout register x:int, register y:int)
    ensures
        x == old(x + y);
{
    Add(x, y); // coerces y from register to operand
}

procedure p()
    modifies
        eax;
    requires
        eax >= 0;
    ensures
        eax >= 2;
{
    Increment(eax);
    Increment(eax);
}

#verbatim
let double (x:int):int = x + x
#endverbatim

procedure Calls()
    modifies
        eax; ebx;
    ensures
        eax == old(eax) + 3;
{
    Increment(eax);
    Imm(ebx, double(1));
    assert ebx == 2;
    Add(eax, ebx);
}

procedure Ghosts(ghost g1:int) returns(ghost g2:int)
    ensures
        g2 == g1 + 1;
{
    g2 := g1 + 1;
}

*/
